<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx"
	xsi:schemaLocation="http://www.springframework.org/schema/beans 
		http://www.springframework.org/schema/beans/spring-beans-3.2.xsd 
		http://www.springframework.org/schema/mvc 
		http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd 
		http://www.springframework.org/schema/context 
		http://www.springframework.org/schema/context/spring-context-3.2.xsd 
		http://www.springframework.org/schema/aop 
		http://www.springframework.org/schema/aop/spring-aop-3.2.xsd 
		http://www.springframework.org/schema/tx 
		http://www.springframework.org/schema/tx/spring-tx-3.2.xsd ">

	<!--
		ConnectionFactory是用于产生到JMS服务器的链接的，spring为我们提供了多个ConnectionFactory,有SingleConnectionFactory和CachingConnectionFactory
		SingleConnectionFactory对于建立JMS服务链接的请求会一直返回同一个链接；并且忽略Connection的close方法调用。
		CachingConnectionFactory继承了SingleConnectionFactory，它拥有SingleConnectionFactory的所有功能；同时它还新增了缓存功能，它可以缓存Session、MessageProducer和MessageConsumer。
	-->



	<!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供-->
	<!--<bean id="targetConnectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory">
		<property name="brokerURL" value="tcp://localhost:61616"/>
	</bean>-->

	<!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory -->
	<!--<bean id="connectionFactory" class="org.springframework.jms.connection.SingleConnectionFactory">
		&lt;!&ndash; 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory &ndash;&gt;
		<property name="targetConnectionFactory" ref="targetConnectionFactory"/>
	</bean>-->

	<!--
		ActiveMQ为我们提供了一个PooledConnectionFactory，通过往里面注入一个ActiveMQConnectionFactory可以用来将Connection、Session和MessageProducer池化，
		这样可以大大的减少我们的资源消耗。当使用PooledConnectionFactory时，我们在定义一个ConnectionFactory时应该是如下定义：
	-->
	<!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供-->
	<bean id="targetConnectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory">
		<property name="brokerURL" value="tcp://localhost:61616"/>
	</bean>

	<bean id="pooledConnectionFactory" class="org.apache.activemq.pool.PooledConnectionFactory">
		<property name="connectionFactory" ref="targetConnectionFactory"/>
		<property name="maxConnections" value="10"/>
	</bean>

	<bean id="connectionFactory" class="org.springframework.jms.connection.SingleConnectionFactory">
		<property name="targetConnectionFactory" ref="pooledConnectionFactory"/>
	</bean>

	<!--
		*******************************配置生产者*************************************
		Spring提供的JMS工具类，它可以进行消息发送、接收等
	 	********************************************************************
	 -->
	<bean id="jmsTemplate" class="org.springframework.jms.core.JmsTemplate">
		<!-- 这个connectionFactory对应的是我们定义的Spring提供的那个ConnectionFactory对象 -->
		<property name="connectionFactory" ref="connectionFactory"/>
	</bean>


	<!--

		 在真正利用JmsTemplate进行消息发送的时候，我们需要知道消息发送的目的地，即destination。在Jms中有一个用来表示目的地的Destination接口，
		 它里面没有任何方法定义，只是用来做一个标识而已。当我们在使用JmsTemplate进行消息发送时没有指定destination的时候将使用默认的Destination。
		 默认Destination可以通过在定义jmsTemplate bean对象时通过属性defaultDestination或defaultDestinationName来进行注入，
		 defaultDestinationName对应的就是一个普通字符串。在ActiveMQ中实现了两种类型的Destination，一个是点对点的ActiveMQQueue，
		 另一个就是支持订阅/发布模式的ActiveMQTopic。在定义这两种类型的Destination时我们都可以通过一个name属性来进行构造，如：

	-->
	<!--这个是队列目的地，点对点的-->
	<bean id="queueDestination" class="org.apache.activemq.command.ActiveMQQueue">
		<constructor-arg>
			<value>queue</value>
		</constructor-arg>
	</bean>
	<!--这个是主题目的地，一对多的-->
	<bean id="topicDestination" class="org.apache.activemq.command.ActiveMQTopic">
		<constructor-arg value="topic"/>
	</bean>



</beans>